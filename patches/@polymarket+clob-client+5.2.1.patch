diff --git a/node_modules/@polymarket/clob-client/dist/client.js b/node_modules/@polymarket/clob-client/dist/client.js
index a2d1a1b..2e1971a 100644
--- a/node_modules/@polymarket/clob-client/dist/client.js
+++ b/node_modules/@polymarket/clob-client/dist/client.js
@@ -9,6 +9,25 @@ import { OrderBuilder } from "./order-builder/builder.js";
 import { END_CURSOR, INITIAL_CURSOR } from "./constants.js";
 import { calculateBuyMarketPrice, calculateSellMarketPrice } from "./order-builder/helpers.js";
 import { RfqClient } from "./rfq-client.js";
+
+// Helper function to build deterministic query string for signed requests
+function buildCanonicalQueryString(params) {
+    if (!params || Object.keys(params).length === 0) {
+        return "";
+    }
+    const filtered = Object.fromEntries(
+        Object.entries(params).filter(([, value]) => value !== undefined)
+    );
+    const keys = Object.keys(filtered).sort();
+    if (keys.length === 0) {
+        return "";
+    }
+    const queryString = keys
+        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(String(filtered[key]))}`)
+        .join("&");
+    return queryString;
+}
+
 export class ClobClient {
     host;
     chainId;
@@ -411,16 +430,19 @@ export class ClobClient {
     async getBalanceAllowance(params) {
         this.canL2Auth();
         const endpoint = GET_BALANCE_ALLOWANCE;
-        const headerArgs = {
-            method: GET,
-            requestPath: endpoint,
-        };
-        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
         const _params = {
             ...params,
             signature_type: this.orderBuilder.signatureType,
         };
-        return this.get(`${this.host}${endpoint}`, { headers, params: _params });
+        const queryString = buildCanonicalQueryString(_params);
+        const requestPath = queryString ? `${endpoint}?${queryString}` : endpoint;
+        const headerArgs = {
+            method: GET,
+            requestPath: requestPath,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        const fullUrl = queryString ? `${this.host}${endpoint}?${queryString}` : `${this.host}${endpoint}`;
+        return this.get(fullUrl, { headers });
     }
     async updateBalanceAllowance(params) {
         this.canL2Auth();
diff --git a/node_modules/@polymarket/clob-client/dist/client.js.orig b/node_modules/@polymarket/clob-client/dist/client.js.orig
new file mode 100644
index 0000000..a2d1a1b
--- /dev/null
+++ b/node_modules/@polymarket/clob-client/dist/client.js.orig
@@ -0,0 +1,877 @@
+import { SignatureType } from "@polymarket/order-utils";
+import { OrderType, Side } from "./types.js";
+import { createL1Headers, createL2Headers, injectBuilderHeaders } from "./headers/index.js";
+import { del, DELETE, GET, get, parseDropNotificationParams, POST, post, put, } from "./http-helpers/index.js";
+import { BUILDER_AUTH_FAILED, BUILDER_AUTH_NOT_AVAILABLE, L1_AUTH_UNAVAILABLE_ERROR, L2_AUTH_NOT_AVAILABLE } from "./errors.js";
+import { generateOrderBookSummaryHash, isTickSizeSmaller, orderToJson, priceValid, } from "./utilities.js";
+import { CANCEL_ALL, CANCEL_ORDER, CREATE_API_KEY, GET_API_KEYS, CLOSED_ONLY, GET_ORDER, POST_ORDER, TIME, GET_TRADES, GET_ORDER_BOOK, DELETE_API_KEY, GET_MIDPOINT, GET_PRICE, GET_OPEN_ORDERS, DERIVE_API_KEY, GET_LAST_TRADE_PRICE, GET_MARKETS, GET_MARKET, GET_PRICES_HISTORY, GET_NOTIFICATIONS, DROP_NOTIFICATIONS, CANCEL_ORDERS, CANCEL_MARKET_ORDERS, GET_BALANCE_ALLOWANCE, IS_ORDER_SCORING, GET_TICK_SIZE, GET_NEG_RISK, ARE_ORDERS_SCORING, GET_SIMPLIFIED_MARKETS, GET_SAMPLING_SIMPLIFIED_MARKETS, GET_SAMPLING_MARKETS, GET_MARKET_TRADES_EVENTS, GET_ORDER_BOOKS, GET_MIDPOINTS, GET_PRICES, GET_LAST_TRADES_PRICES, GET_EARNINGS_FOR_USER_FOR_DAY, GET_LIQUIDITY_REWARD_PERCENTAGES, GET_REWARDS_MARKETS_CURRENT, GET_REWARDS_MARKETS, GET_REWARDS_EARNINGS_PERCENTAGES, GET_TOTAL_EARNINGS_FOR_USER_FOR_DAY, GET_SPREAD, GET_SPREADS, UPDATE_BALANCE_ALLOWANCE, POST_ORDERS, GET_FEE_RATE, GET_BUILDER_TRADES, CREATE_BUILDER_API_KEY, GET_BUILDER_API_KEYS, REVOKE_BUILDER_API_KEY, CREATE_READONLY_API_KEY, GET_READONLY_API_KEYS, DELETE_READONLY_API_KEY, VALIDATE_READONLY_API_KEY, POST_HEARTBEAT, } from "./endpoints.js";
+import { OrderBuilder } from "./order-builder/builder.js";
+import { END_CURSOR, INITIAL_CURSOR } from "./constants.js";
+import { calculateBuyMarketPrice, calculateSellMarketPrice } from "./order-builder/helpers.js";
+import { RfqClient } from "./rfq-client.js";
+export class ClobClient {
+    host;
+    chainId;
+    // Used to perform Level 1 authentication and sign orders
+    signer;
+    // Used to perform Level 2 authentication
+    creds;
+    orderBuilder;
+    tickSizes;
+    negRisk;
+    feeRates;
+    geoBlockToken;
+    useServerTime;
+    builderConfig;
+    rfq;
+    retryOnError;
+    // eslint-disable-next-line max-params
+    constructor(host, chainId, signer, creds, signatureType, funderAddress, geoBlockToken, useServerTime, builderConfig, getSigner, retryOnError) {
+        this.host = host.endsWith("/") ? host.slice(0, -1) : host;
+        this.chainId = chainId;
+        if (signer !== undefined) {
+            this.signer = signer;
+        }
+        if (creds !== undefined) {
+            this.creds = creds;
+        }
+        this.orderBuilder = new OrderBuilder(signer, chainId, signatureType, funderAddress, getSigner);
+        this.tickSizes = {};
+        this.negRisk = {};
+        this.feeRates = {};
+        this.geoBlockToken = geoBlockToken;
+        this.useServerTime = useServerTime;
+        this.retryOnError = retryOnError;
+        if (builderConfig !== undefined) {
+            this.builderConfig = builderConfig;
+        }
+        const rfqDeps = {
+            host: this.host,
+            signer: this.signer,
+            creds: this.creds,
+            useServerTime: this.useServerTime,
+            geoBlockToken: this.geoBlockToken,
+            userType: this.orderBuilder.signatureType,
+            getServerTime: this.getServerTime.bind(this),
+            getTickSize: this.getTickSize.bind(this),
+            resolveTickSize: this._resolveTickSize.bind(this),
+            createOrder: this.createOrder.bind(this),
+            get: this.get.bind(this),
+            post: this.post.bind(this),
+            put: this.put.bind(this),
+            del: this.del.bind(this),
+        };
+        this.rfq = new RfqClient(rfqDeps);
+    }
+    // Public endpoints
+    async getOk() {
+        return this.get(`${this.host}/`);
+    }
+    async getServerTime() {
+        return this.get(`${this.host}${TIME}`);
+    }
+    async getSamplingSimplifiedMarkets(next_cursor = INITIAL_CURSOR) {
+        return this.get(`${this.host}${GET_SAMPLING_SIMPLIFIED_MARKETS}`, {
+            params: { next_cursor },
+        });
+    }
+    async getSamplingMarkets(next_cursor = INITIAL_CURSOR) {
+        return this.get(`${this.host}${GET_SAMPLING_MARKETS}`, {
+            params: { next_cursor },
+        });
+    }
+    async getSimplifiedMarkets(next_cursor = INITIAL_CURSOR) {
+        return this.get(`${this.host}${GET_SIMPLIFIED_MARKETS}`, {
+            params: { next_cursor },
+        });
+    }
+    async getMarkets(next_cursor = INITIAL_CURSOR) {
+        return this.get(`${this.host}${GET_MARKETS}`, {
+            params: { next_cursor },
+        });
+    }
+    async getMarket(conditionID) {
+        return this.get(`${this.host}${GET_MARKET}${conditionID}`);
+    }
+    async getOrderBook(tokenID) {
+        return this.get(`${this.host}${GET_ORDER_BOOK}`, {
+            params: { token_id: tokenID },
+        });
+    }
+    async getOrderBooks(params) {
+        return this.post(`${this.host}${GET_ORDER_BOOKS}`, {
+            data: params,
+        });
+    }
+    async getTickSize(tokenID) {
+        if (tokenID in this.tickSizes) {
+            return this.tickSizes[tokenID];
+        }
+        const result = await this.get(`${this.host}${GET_TICK_SIZE}`, {
+            params: { token_id: tokenID },
+        });
+        this.tickSizes[tokenID] = result.minimum_tick_size.toString();
+        return this.tickSizes[tokenID];
+    }
+    async getNegRisk(tokenID) {
+        if (tokenID in this.negRisk) {
+            return this.negRisk[tokenID];
+        }
+        const result = await this.get(`${this.host}${GET_NEG_RISK}`, {
+            params: { token_id: tokenID },
+        });
+        this.negRisk[tokenID] = result.neg_risk;
+        return this.negRisk[tokenID];
+    }
+    async getFeeRateBps(tokenID) {
+        if (tokenID in this.feeRates) {
+            return this.feeRates[tokenID];
+        }
+        const result = await this.get(`${this.host}${GET_FEE_RATE}`, {
+            params: { token_id: tokenID },
+        });
+        this.feeRates[tokenID] = result.base_fee;
+        return this.feeRates[tokenID];
+    }
+    /**
+     * Calculates the hash for the given orderbook
+     * @param orderbook
+     * @returns
+     */
+    getOrderBookHash(orderbook) {
+        return generateOrderBookSummaryHash(orderbook);
+    }
+    async getMidpoint(tokenID) {
+        return this.get(`${this.host}${GET_MIDPOINT}`, {
+            params: { token_id: tokenID },
+        });
+    }
+    async getMidpoints(params) {
+        return this.post(`${this.host}${GET_MIDPOINTS}`, {
+            data: params,
+        });
+    }
+    async getPrice(tokenID, side) {
+        return this.get(`${this.host}${GET_PRICE}`, {
+            params: { token_id: tokenID, side: side },
+        });
+    }
+    async getPrices(params) {
+        return this.post(`${this.host}${GET_PRICES}`, {
+            data: params,
+        });
+    }
+    async getSpread(tokenID) {
+        return this.get(`${this.host}${GET_SPREAD}`, {
+            params: { token_id: tokenID },
+        });
+    }
+    async getSpreads(params) {
+        return this.post(`${this.host}${GET_SPREADS}`, {
+            data: params,
+        });
+    }
+    async getLastTradePrice(tokenID) {
+        return this.get(`${this.host}${GET_LAST_TRADE_PRICE}`, {
+            params: { token_id: tokenID },
+        });
+    }
+    async getLastTradesPrices(params) {
+        return this.post(`${this.host}${GET_LAST_TRADES_PRICES}`, {
+            data: params,
+        });
+    }
+    async getPricesHistory(params) {
+        return this.get(`${this.host}${GET_PRICES_HISTORY}`, {
+            params,
+        });
+    }
+    // L1 Authed
+    /**
+     * Creates a new API key for a user
+     * @param nonce
+     * @returns ApiKeyCreds
+     */
+    async createApiKey(nonce) {
+        this.canL1Auth();
+        const endpoint = `${this.host}${CREATE_API_KEY}`;
+        const headers = await createL1Headers(this.signer, this.chainId, nonce, this.useServerTime ? await this.getServerTime() : undefined);
+        return await this.post(endpoint, { headers }).then((apiKeyRaw) => {
+            const apiKey = {
+                key: apiKeyRaw.apiKey,
+                secret: apiKeyRaw.secret,
+                passphrase: apiKeyRaw.passphrase,
+            };
+            return apiKey;
+        });
+    }
+    /**
+     * Derives an existing API key for a user
+     * @param nonce
+     * @returns ApiKeyCreds
+     */
+    async deriveApiKey(nonce) {
+        this.canL1Auth();
+        const endpoint = `${this.host}${DERIVE_API_KEY}`;
+        const headers = await createL1Headers(this.signer, this.chainId, nonce, this.useServerTime ? await this.getServerTime() : undefined);
+        return await this.get(endpoint, { headers }).then((apiKeyRaw) => {
+            const apiKey = {
+                key: apiKeyRaw.apiKey,
+                secret: apiKeyRaw.secret,
+                passphrase: apiKeyRaw.passphrase,
+            };
+            return apiKey;
+        });
+    }
+    async createOrDeriveApiKey(nonce) {
+        return this.createApiKey(nonce).then(response => {
+            if (!response.key) {
+                return this.deriveApiKey(nonce);
+            }
+            return response;
+        });
+    }
+    async getApiKeys() {
+        this.canL2Auth();
+        const endpoint = GET_API_KEYS;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, { headers });
+    }
+    async getClosedOnlyMode() {
+        this.canL2Auth();
+        const endpoint = CLOSED_ONLY;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, { headers });
+    }
+    async deleteApiKey() {
+        this.canL2Auth();
+        const endpoint = DELETE_API_KEY;
+        const headerArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, { headers });
+    }
+    /**
+     * Creates a new readonly API key for a user
+     * @returns ReadonlyApiKeyResponse
+     */
+    async createReadonlyApiKey() {
+        this.canL2Auth();
+        const endpoint = CREATE_READONLY_API_KEY;
+        const headerArgs = {
+            method: POST,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.post(`${this.host}${endpoint}`, { headers });
+    }
+    async getReadonlyApiKeys() {
+        this.canL2Auth();
+        const endpoint = GET_READONLY_API_KEYS;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, { headers });
+    }
+    /**
+     * Deletes a readonly API key for a user
+     * @param key The readonly API key to delete
+     * @returns boolean
+     */
+    async deleteReadonlyApiKey(key) {
+        this.canL2Auth();
+        const endpoint = DELETE_READONLY_API_KEY;
+        const payload = { key };
+        const headerArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+            body: JSON.stringify(payload),
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, { headers, data: payload });
+    }
+    /**
+     * Validates a readonly API key for a given address
+     * @param address The wallet address
+     * @param key The readonly API key to validate
+     * @returns string
+     */
+    async validateReadonlyApiKey(address, key) {
+        return this.get(`${this.host}${VALIDATE_READONLY_API_KEY}`, {
+            params: { address, key },
+        });
+    }
+    async getOrder(orderID) {
+        this.canL2Auth();
+        const endpoint = `${GET_ORDER}${orderID}`;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, { headers });
+    }
+    async getTrades(params, only_first_page = false, next_cursor) {
+        this.canL2Auth();
+        const endpoint = GET_TRADES;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        let results = [];
+        next_cursor = next_cursor || INITIAL_CURSOR;
+        while (next_cursor != END_CURSOR && (next_cursor === INITIAL_CURSOR || !only_first_page)) {
+            const _params = {
+                ...params,
+                next_cursor,
+            };
+            const response = await this.get(`${this.host}${endpoint}`, {
+                headers,
+                params: _params,
+            });
+            next_cursor = response.next_cursor;
+            results = [...results, ...response.data];
+        }
+        return results;
+    }
+    async getTradesPaginated(params, next_cursor) {
+        this.canL2Auth();
+        const endpoint = GET_TRADES;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        next_cursor = next_cursor || INITIAL_CURSOR;
+        const _params = { ...params, next_cursor };
+        const { data, ...rest } = await this.get(`${this.host}${endpoint}`, {
+            headers,
+            params: _params,
+        });
+        return { trades: Array.isArray(data) ? [...data] : [], ...rest };
+    }
+    async getBuilderTrades(params, next_cursor) {
+        this.mustBuilderAuth();
+        const endpoint = GET_BUILDER_TRADES;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await this._getBuilderHeaders(headerArgs.method, headerArgs.requestPath);
+        if (headers == undefined) {
+            throw BUILDER_AUTH_FAILED;
+        }
+        next_cursor = next_cursor || INITIAL_CURSOR;
+        const _params = { ...params, next_cursor };
+        const { data, ...rest } = await this.get(`${this.host}${endpoint}`, {
+            headers,
+            params: _params,
+        });
+        return { trades: Array.isArray(data) ? [...data] : [], ...rest };
+    }
+    async getNotifications() {
+        this.canL2Auth();
+        const endpoint = GET_NOTIFICATIONS;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, {
+            headers,
+            params: { signature_type: this.orderBuilder.signatureType },
+        });
+    }
+    async dropNotifications(params) {
+        this.canL2Auth();
+        const endpoint = DROP_NOTIFICATIONS;
+        const l2HeaderArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, {
+            headers,
+            params: parseDropNotificationParams(params),
+        });
+    }
+    async getBalanceAllowance(params) {
+        this.canL2Auth();
+        const endpoint = GET_BALANCE_ALLOWANCE;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        const _params = {
+            ...params,
+            signature_type: this.orderBuilder.signatureType,
+        };
+        return this.get(`${this.host}${endpoint}`, { headers, params: _params });
+    }
+    async updateBalanceAllowance(params) {
+        this.canL2Auth();
+        const endpoint = UPDATE_BALANCE_ALLOWANCE;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        const _params = {
+            ...params,
+            signature_type: this.orderBuilder.signatureType,
+        };
+        return this.get(`${this.host}${endpoint}`, { headers, params: _params });
+    }
+    async createOrder(userOrder, options) {
+        this.canL1Auth();
+        const { tokenID } = userOrder;
+        const tickSize = await this._resolveTickSize(tokenID, options?.tickSize);
+        const feeRateBps = await this._resolveFeeRateBps(tokenID, userOrder.feeRateBps);
+        userOrder.feeRateBps = feeRateBps;
+        if (!priceValid(userOrder.price, tickSize)) {
+            throw new Error(`invalid price (${userOrder.price}), min: ${parseFloat(tickSize)} - max: ${1 - parseFloat(tickSize)}`);
+        }
+        const negRisk = options?.negRisk ?? (await this.getNegRisk(tokenID));
+        return this.orderBuilder.buildOrder(userOrder, {
+            tickSize,
+            negRisk,
+        });
+    }
+    async createMarketOrder(userMarketOrder, options) {
+        this.canL1Auth();
+        const { tokenID } = userMarketOrder;
+        const tickSize = await this._resolveTickSize(tokenID, options?.tickSize);
+        const feeRateBps = await this._resolveFeeRateBps(tokenID, userMarketOrder.feeRateBps);
+        userMarketOrder.feeRateBps = feeRateBps;
+        if (!userMarketOrder.price) {
+            userMarketOrder.price = await this.calculateMarketPrice(tokenID, userMarketOrder.side, userMarketOrder.amount, userMarketOrder.orderType);
+        }
+        if (!priceValid(userMarketOrder.price, tickSize)) {
+            throw new Error(`invalid price (${userMarketOrder.price}), min: ${parseFloat(tickSize)} - max: ${1 - parseFloat(tickSize)}`);
+        }
+        const negRisk = options?.negRisk ?? (await this.getNegRisk(tokenID));
+        return this.orderBuilder.buildMarketOrder(userMarketOrder, {
+            tickSize,
+            negRisk,
+        });
+    }
+    async createAndPostOrder(userOrder, options, orderType = OrderType.GTC, deferExec = false, postOnly = false) {
+        const order = await this.createOrder(userOrder, options);
+        return this.postOrder(order, orderType, deferExec, postOnly);
+    }
+    async createAndPostMarketOrder(userMarketOrder, options, orderType = OrderType.FOK, deferExec = false) {
+        const order = await this.createMarketOrder(userMarketOrder, options);
+        return this.postOrder(order, orderType, deferExec);
+    }
+    async getOpenOrders(params, only_first_page = false, next_cursor) {
+        this.canL2Auth();
+        const endpoint = GET_OPEN_ORDERS;
+        const l2HeaderArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        let results = [];
+        next_cursor = next_cursor || INITIAL_CURSOR;
+        while (next_cursor != END_CURSOR && (next_cursor === INITIAL_CURSOR || !only_first_page)) {
+            const _params = {
+                ...params,
+                next_cursor,
+            };
+            const response = await this.get(`${this.host}${endpoint}`, {
+                headers,
+                params: _params,
+            });
+            next_cursor = response.next_cursor;
+            results = [...results, ...response.data];
+        }
+        return results;
+    }
+    async postOrder(order, orderType = OrderType.GTC, deferExec = false, postOnly = false) {
+        this.canL2Auth();
+        const endpoint = POST_ORDER;
+        const orderPayload = orderToJson(order, this.creds?.key || "", orderType, deferExec, postOnly);
+        const l2HeaderArgs = {
+            method: POST,
+            requestPath: endpoint,
+            body: JSON.stringify(orderPayload),
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        // builders flow
+        if (this.canBuilderAuth()) {
+            const builderHeaders = await this._generateBuilderHeaders(headers, l2HeaderArgs);
+            if (builderHeaders !== undefined) {
+                return this.post(`${this.host}${endpoint}`, { headers: builderHeaders, data: orderPayload });
+            }
+        }
+        return this.post(`${this.host}${endpoint}`, { headers, data: orderPayload });
+    }
+    async postOrders(args, deferExec = false, defaultPostOnly = false) {
+        this.canL2Auth();
+        const endpoint = POST_ORDERS;
+        const ordersPayload = [];
+        for (const { order, orderType, postOnly: orderPostOnly } of args) {
+            const orderPayload = orderToJson(order, this.creds?.key || "", orderType, deferExec, orderPostOnly ?? defaultPostOnly);
+            ordersPayload.push(orderPayload);
+        }
+        const l2HeaderArgs = {
+            method: POST,
+            requestPath: endpoint,
+            body: JSON.stringify(ordersPayload),
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        // builders flow
+        if (this.canBuilderAuth()) {
+            const builderHeaders = await this._generateBuilderHeaders(headers, l2HeaderArgs);
+            if (builderHeaders !== undefined) {
+                return this.post(`${this.host}${endpoint}`, { headers: builderHeaders, data: ordersPayload });
+            }
+        }
+        return this.post(`${this.host}${endpoint}`, { headers, data: ordersPayload });
+    }
+    async cancelOrder(payload) {
+        this.canL2Auth();
+        const endpoint = CANCEL_ORDER;
+        const l2HeaderArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+            body: JSON.stringify(payload),
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, { headers, data: payload });
+    }
+    async cancelOrders(ordersHashes) {
+        this.canL2Auth();
+        const endpoint = CANCEL_ORDERS;
+        const l2HeaderArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+            body: JSON.stringify(ordersHashes),
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, { headers, data: ordersHashes });
+    }
+    async cancelAll() {
+        this.canL2Auth();
+        const endpoint = CANCEL_ALL;
+        const l2HeaderArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, { headers });
+    }
+    /**
+     * Sends a heartbeat to the server to keep the session active.
+     *
+     * If heartbeats are started and one isn't sent within 10s, all orders will be cancelled.
+     * Requires Level 2 authentication.
+     *
+     * Pass the previously returned `heartbeat_id` to chain heartbeats.
+     * Pass `undefined`/`null` to start a new heartbeat chain.
+     */
+    async postHeartbeat(heartbeatId) {
+        this.canL2Auth();
+        const endpoint = POST_HEARTBEAT;
+        const bodyObj = { heartbeat_id: heartbeatId ?? null };
+        const serialized = JSON.stringify(bodyObj);
+        const l2HeaderArgs = {
+            method: POST,
+            requestPath: endpoint,
+            body: serialized,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.post(`${this.host}${endpoint}`, { headers, data: serialized });
+    }
+    async cancelMarketOrders(payload) {
+        this.canL2Auth();
+        const endpoint = CANCEL_MARKET_ORDERS;
+        const l2HeaderArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+            body: JSON.stringify(payload),
+        };
+        const headers = await createL2Headers(this.signer, this.creds, l2HeaderArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.del(`${this.host}${endpoint}`, { headers, data: payload });
+    }
+    async isOrderScoring(params) {
+        this.canL2Auth();
+        const endpoint = IS_ORDER_SCORING;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, { headers, params });
+    }
+    async areOrdersScoring(params) {
+        this.canL2Auth();
+        const endpoint = ARE_ORDERS_SCORING;
+        const payload = JSON.stringify(params?.orderIds);
+        const headerArgs = {
+            method: POST,
+            requestPath: endpoint,
+            body: payload,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.post(`${this.host}${endpoint}`, {
+            headers,
+            data: payload,
+        });
+    }
+    // Rewards
+    async getEarningsForUserForDay(date) {
+        this.canL2Auth();
+        const endpoint = GET_EARNINGS_FOR_USER_FOR_DAY;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        let results = [];
+        let next_cursor = INITIAL_CURSOR;
+        while (next_cursor != END_CURSOR) {
+            const params = {
+                date,
+                signature_type: this.orderBuilder.signatureType,
+                next_cursor,
+            };
+            const response = await this.get(`${this.host}${endpoint}`, {
+                headers,
+                params,
+            });
+            next_cursor = response.next_cursor;
+            results = [...results, ...response.data];
+        }
+        return results;
+    }
+    async getTotalEarningsForUserForDay(date) {
+        this.canL2Auth();
+        const endpoint = GET_TOTAL_EARNINGS_FOR_USER_FOR_DAY;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        const params = {
+            date,
+            signature_type: this.orderBuilder.signatureType,
+        };
+        return await this.get(`${this.host}${endpoint}`, {
+            headers,
+            params,
+        });
+    }
+    async getUserEarningsAndMarketsConfig(date, order_by = "", position = "", no_competition = false) {
+        this.canL2Auth();
+        const endpoint = GET_REWARDS_EARNINGS_PERCENTAGES;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        let results = [];
+        let next_cursor = INITIAL_CURSOR;
+        while (next_cursor != END_CURSOR) {
+            const params = {
+                date,
+                signature_type: this.orderBuilder.signatureType,
+                next_cursor,
+                order_by,
+                position,
+                no_competition,
+            };
+            const response = await this.get(`${this.host}${endpoint}`, {
+                headers,
+                params,
+            });
+            next_cursor = response.next_cursor;
+            results = [...results, ...response.data];
+        }
+        return results;
+    }
+    async getRewardPercentages() {
+        this.canL2Auth();
+        const endpoint = GET_LIQUIDITY_REWARD_PERCENTAGES;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        const _params = {
+            signature_type: this.orderBuilder.signatureType,
+        };
+        return this.get(`${this.host}${endpoint}`, { headers, params: _params });
+    }
+    async getCurrentRewards() {
+        let results = [];
+        let next_cursor = INITIAL_CURSOR;
+        while (next_cursor != END_CURSOR) {
+            const response = await this.get(`${this.host}${GET_REWARDS_MARKETS_CURRENT}`, {
+                params: { next_cursor },
+            });
+            next_cursor = response.next_cursor;
+            results = [...results, ...response.data];
+        }
+        return results;
+    }
+    async getRawRewardsForMarket(conditionId) {
+        let results = [];
+        let next_cursor = INITIAL_CURSOR;
+        while (next_cursor != END_CURSOR) {
+            const response = await this.get(`${this.host}${GET_REWARDS_MARKETS}${conditionId}`, {
+                params: { next_cursor },
+            });
+            next_cursor = response.next_cursor;
+            results = [...results, ...response.data];
+        }
+        return results;
+    }
+    async getMarketTradesEvents(conditionID) {
+        return this.get(`${this.host}${GET_MARKET_TRADES_EVENTS}${conditionID}`);
+    }
+    async calculateMarketPrice(tokenID, side, amount, orderType = OrderType.FOK) {
+        const book = await this.getOrderBook(tokenID);
+        if (!book) {
+            throw new Error("no orderbook");
+        }
+        if (side === Side.BUY) {
+            if (!book.asks) {
+                throw new Error("no match");
+            }
+            return calculateBuyMarketPrice(book.asks, amount, orderType);
+        }
+        else {
+            if (!book.bids) {
+                throw new Error("no match");
+            }
+            return calculateSellMarketPrice(book.bids, amount, orderType);
+        }
+    }
+    async createBuilderApiKey() {
+        this.canL2Auth();
+        const endpoint = CREATE_BUILDER_API_KEY;
+        const headerArgs = {
+            method: POST,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.post(`${this.host}${endpoint}`, { headers });
+    }
+    async getBuilderApiKeys() {
+        this.canL2Auth();
+        const endpoint = GET_BUILDER_API_KEYS;
+        const headerArgs = {
+            method: GET,
+            requestPath: endpoint,
+        };
+        const headers = await createL2Headers(this.signer, this.creds, headerArgs, this.useServerTime ? await this.getServerTime() : undefined);
+        return this.get(`${this.host}${endpoint}`, { headers });
+    }
+    async revokeBuilderApiKey() {
+        this.mustBuilderAuth();
+        const endpoint = REVOKE_BUILDER_API_KEY;
+        const headerArgs = {
+            method: DELETE,
+            requestPath: endpoint,
+        };
+        const headers = await this._getBuilderHeaders(headerArgs.method, headerArgs.requestPath);
+        if (headers == undefined) {
+            throw BUILDER_AUTH_FAILED;
+        }
+        return this.del(`${this.host}${endpoint}`, { headers });
+    }
+    async _resolveTickSize(tokenID, tickSize) {
+        const minTickSize = await this.getTickSize(tokenID);
+        if (tickSize) {
+            if (isTickSizeSmaller(tickSize, minTickSize)) {
+                throw new Error(`invalid tick size (${tickSize}), minimum for the market is ${minTickSize}`);
+            }
+        }
+        else {
+            tickSize = minTickSize;
+        }
+        return tickSize;
+    }
+    // http methods
+    async get(endpoint, options) {
+        return get(endpoint, {
+            ...options,
+            params: { ...options?.params, geo_block_token: this.geoBlockToken },
+        });
+    }
+    async post(endpoint, options) {
+        return post(endpoint, {
+            ...options,
+            params: { ...options?.params, geo_block_token: this.geoBlockToken },
+        }, this.retryOnError);
+    }
+    async put(endpoint, options) {
+        return put(endpoint, {
+            ...options,
+            params: { ...options?.params, geo_block_token: this.geoBlockToken },
+        });
+    }
+    async del(endpoint, options) {
+        return del(endpoint, {
+            ...options,
+            params: { ...options?.params, geo_block_token: this.geoBlockToken },
+        });
+    }
+    canL1Auth() {
+        if (this.signer === undefined) {
+            throw L1_AUTH_UNAVAILABLE_ERROR;
+        }
+    }
+    canL2Auth() {
+        if (this.signer === undefined) {
+            throw L1_AUTH_UNAVAILABLE_ERROR;
+        }
+        if (this.creds === undefined) {
+            throw L2_AUTH_NOT_AVAILABLE;
+        }
+    }
+    mustBuilderAuth() {
+        if (!this.canBuilderAuth()) {
+            throw BUILDER_AUTH_NOT_AVAILABLE;
+        }
+    }
+    canBuilderAuth() {
+        return (this.builderConfig != undefined && this.builderConfig.isValid());
+    }
+    async _resolveFeeRateBps(tokenID, userFeeRateBps) {
+        const marketFeeRateBps = await this.getFeeRateBps(tokenID);
+        if (marketFeeRateBps > 0 && userFeeRateBps != undefined && userFeeRateBps != marketFeeRateBps) {
+            throw new Error(`invalid user provided fee rate: ${userFeeRateBps}, fee rate for the market must be ${marketFeeRateBps}`);
+        }
+        return marketFeeRateBps;
+    }
+    async _generateBuilderHeaders(headers, headerArgs) {
+        if (this.builderConfig !== undefined) {
+            const builderHeaders = await this._getBuilderHeaders(headerArgs.method, headerArgs.requestPath, headerArgs.body);
+            if (builderHeaders == undefined) {
+                return undefined;
+            }
+            return injectBuilderHeaders(headers, builderHeaders);
+        }
+        return undefined;
+    }
+    async _getBuilderHeaders(method, path, body) {
+        return this.builderConfig.generateBuilderHeaders(method, path, body);
+    }
+}
+//# sourceMappingURL=client.js.map
\ No newline at end of file
